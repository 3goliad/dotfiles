return {}
-- return {
--   -- Main LSP Configuration
--   "neovim/nvim-lspconfig",
--   dependencies = {
--     -- Automatically install LSPs and related tools to stdpath for Neovim
--     -- Mason must be loaded before its dependents so we need to set it up here.
--     -- NOTE: `opts = {}` is the same as calling `require('mason').setup({})`
--     { "mason-org/mason.nvim", opts = {} },
--     "mason-org/mason-lspconfig.nvim",
--
--     -- Useful status updates for LSP.
--     { "j-hui/fidget.nvim", opts = {} },
--
--     -- Allows extra capabilities provided by blink.cmp
--     "saghen/blink.cmp",
--   },
--   config = function()
--     -- If you're wondering about lsp vs treesitter, you can check out the wonderfully
--     -- and elegantly composed help section, `:help lsp-vs-treesitter`
--
--     --  This function gets run when an LSP attaches to a particular buffer.
--     --    That is to say, every time a new file is opened that is associated with
--     --    an lsp (for example, opening `main.rs` is associated with `rust_analyzer`) this
--     --    function will be executed to configure the current buffer
--     vim.api.nvim_create_autocmd("LspAttach", {
--       group = vim.api.nvim_create_augroup(
--         "kickstart-lsp-attach",
--         { clear = true }
--       ),
--       callback = function(event)
--         -- Rename the variable under your cursor.
--         --  Most Language Servers support renaming across files, etc.
--         Brown.keymaps:add({
--           "grn",
--           vim.lsp.buf.rename,
--           desc = "LSP: [R]e[n]ame",
--           buffer = event.buf,
--         })
--
--         -- Execute a code action, usually your cursor needs to be on top of an error
--         -- or a suggestion from your LSP for this to activate.
--         Brown.keymaps:add({
--           "gra",
--           vim.lsp.buf.code_action,
--           desc = "LSP: [G]oto Code [A]ction",
--           mode = { "n", "x" },
--           buffer = event.buf,
--         })
--
--         -- Find references for the word under your cursor.
--         Brown.keymaps:add({
--           "grr",
--           require("telescope.builtin").lsp_references,
--           desc = "LSP: [G]oto [R]eferences",
--           buffer = event.buf,
--         })
--
--         -- Jump to the implementation of the word under your cursor.
--         --  Useful when your language has ways of declaring types without an actual implementation.
--         Brown.keymaps:add({
--           "gri",
--           require("telescope.builtin").lsp_implementations,
--           desc = "LSP: [G]oto [I]mplementation",
--           buffer = event.buf,
--         })
--
--         -- Jump to the definition of the word under your cursor.
--         --  This is where a variable was first declared, or where a function is defined, etc.
--         --  To jump back, press <C-t>.
--         Brown.keymaps:add({
--           "grd",
--           require("telescope.builtin").lsp_definitions,
--           desc = "LSP: [G]oto [D]efinition",
--           buffer = event.buf,
--         })
--
--         -- WARN: This is not Goto Definition, this is Goto Declaration.
--         --  For example, in C this would take you to the header.
--         Brown.keymaps:add({
--           "grd",
--           vim.lsp.buf.declaration,
--           desc = "LSP: [G]oto [D]eclaration",
--           buffer = event.buf,
--         })
--
--         -- Fuzzy find all the symbols in your current document.
--         --  Symbols are things like variables, functions, types, etc.
--         Brown.keymaps:add({
--           "gO",
--           require("telescope.builtin").lsp_document_symbols,
--           desc = "LSP: Open Document Symbols",
--           buffer = event.buf,
--         })
--
--         -- Fuzzy find all the symbols in your current workspace.
--         --  Similar to document symbols, except searches over your entire project.
--         Brown.keymaps:add({
--           "gW",
--           require("telescope.builtin").lsp_dynamic_workspace_symbols,
--           desc = "Open Workspace Symbols",
--           buffer = event.buf,
--         })
--
--         -- Jump to the type of the word under your cursor.
--         --  Useful when you're not sure what type a variable is and you want to see
--         --  the definition of its *type*, not where it was *defined*.
--         Brown.keymaps:add({
--           "grt",
--           require("telescope.builtin").lsp_type_definitions,
--           desc = "LSP: [G]oto [T]ype Definition",
--           buffer = event.buf,
--         })
--
--         -- This function resolves a difference between neovim nightly (version 0.11) and stable (version 0.10)
--         ---@param client vim.lsp.Client
--         ---@param method vim.lsp.protocol.Method
--         ---@param bufnr? integer some lsp support methods only in specific files
--         ---@return boolean
--         local function client_supports_method(client, method, bufnr)
--           if vim.fn.has("nvim-0.11") == 1 then
--             return client:supports_method(method, bufnr)
--           else
--             return client.supports_method(method, { bufnr = bufnr })
--           end
--         end
--
--         -- The following two autocommands are used to highlight references of the
--         -- word under your cursor when your cursor rests there for a little while.
--         --    See `:help CursorHold` for information about when this is executed
--         --
--         -- When you move your cursor, the highlights will be cleared (the second autocommand).
--         local client = vim.lsp.get_client_by_id(event.data.client_id)
--         if
--           client
--           and client_supports_method(
--             client,
--             vim.lsp.protocol.Methods.textDocument_documentHighlight,
--             event.buf
--           )
--         then
--           local highlight_augroup = vim.api.nvim_create_augroup(
--             "kickstart-lsp-highlight",
--             { clear = false }
--           )
--           vim.api.nvim_create_autocmd({ "CursorHold", "CursorHoldI" }, {
--             buffer = event.buf,
--             group = highlight_augroup,
--             callback = vim.lsp.buf.document_highlight,
--           })
--
--           vim.api.nvim_create_autocmd({ "CursorMoved", "CursorMovedI" }, {
--             buffer = event.buf,
--             group = highlight_augroup,
--             callback = vim.lsp.buf.clear_references,
--           })
--
--           vim.api.nvim_create_autocmd("LspDetach", {
--             group = vim.api.nvim_create_augroup(
--               "kickstart-lsp-detach",
--               { clear = true }
--             ),
--             callback = function(event2)
--               vim.lsp.buf.clear_references()
--               vim.api.nvim_clear_autocmds({
--                 group = "kickstart-lsp-highlight",
--                 buffer = event2.buf,
--               })
--             end,
--           })
--         end
--
--         -- The following code creates a keymap to toggle inlay hints in your
--         -- code, if the language server you are using supports them
--         --
--         -- This may be unwanted, since they displace some of your code
--         if
--           client
--           and client_supports_method(
--             client,
--             vim.lsp.protocol.Methods.textDocument_inlayHint,
--             event.buf
--           )
--         then
--           Brown.keymaps.t:add({
--             "h",
--             function()
--               vim.lsp.inlay_hint.enable(
--                 not vim.lsp.inlay_hint.is_enabled({ bufnr = event.buf })
--               )
--             end,
--             desc = "[T]oggle Inlay [H]ints",
--           })
--         end
--       end,
--     })
--
--     -- Diagnostic Config
--     -- See :help vim.diagnostic.Opts
--     vim.diagnostic.config({
--       severity_sort = true,
--       float = { border = "rounded", source = "if_many" },
--       underline = { severity = vim.diagnostic.severity.ERROR },
--       signs = vim.g.have_nerd_font and {
--         text = {
--           [vim.diagnostic.severity.ERROR] = "󰅚 ",
--           [vim.diagnostic.severity.WARN] = "󰀪 ",
--           [vim.diagnostic.severity.INFO] = "󰋽 ",
--           [vim.diagnostic.severity.HINT] = "󰌶 ",
--         },
--       } or {},
--       virtual_text = {
--         source = "if_many",
--         spacing = 2,
--         format = function(diagnostic)
--           local diagnostic_message = {
--             [vim.diagnostic.severity.ERROR] = diagnostic.message,
--             [vim.diagnostic.severity.WARN] = diagnostic.message,
--             [vim.diagnostic.severity.INFO] = diagnostic.message,
--             [vim.diagnostic.severity.HINT] = diagnostic.message,
--           }
--           return diagnostic_message[diagnostic.severity]
--         end,
--       },
--     })
--
--     local capabilities = require("blink.cmp").get_lsp_capabilities()
--
--     local servers = {
--       lua_ls = {
--         settings = {
--           Lua = {
--             completion = {
--               callSnippet = "Replace",
--             },
--             -- You can toggle below to ignore Lua_LS's noisy `missing-fields` warnings
--             -- diagnostics = { disable = { 'missing-fields' } },
--           },
--         },
--       },
--     }
--   end,
-- }
